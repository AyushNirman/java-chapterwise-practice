static int binarySearch(int[] arr, int key) {

    // 1ï¸âƒ£ low = starting index of search space
    //    Binary search always starts from leftmost element
    int low = 0;

    // 2ï¸âƒ£ high = ending index of search space
    //    Last valid index = length - 1
    int high = arr.length - 1;

    // 3ï¸âƒ£ Loop runs while a valid search range exists
    //    If low > high â†’ element not present
    while (low <= high) {

        // 4ï¸âƒ£ Find middle index safely
        //    Prevents integer overflow
        //    mid = (low + high) / 2  âŒ (can overflow)
        int mid = low + (high - low) / 2;

        // 5ï¸âƒ£ If middle element is the key â†’ FOUND
        if (arr[mid] == key)
            return mid;

        // 6ï¸âƒ£ If middle value is smaller than key
        //    Key must be in RIGHT half â†’ discard left half
        else if (arr[mid] < key)
            low = mid + 1;

        // 7ï¸âƒ£ If middle value is greater than key
        //    Key must be in LEFT half â†’ discard right half
        else
            high = mid - 1;
    }

    // 8ï¸âƒ£ If loop ends, element was not found
    return -1;
}




ğŸ”¹ Corner Cases (Interview Traps)

Empty array â†’ return -1

Single element array â†’ still works

Duplicates â†’ returns any occurrence

Integer overflow â†’ always use mid = low + (high - low)/2     




ğŸ§  SHORT INTERVIEW NOTES (WRITE THIS)

Works only on sorted array

Check middle element

Discard half array every step

Stop when low > high

Use low + (high - low)/2 for safety

ğŸ”‘ One-line Memory Trick

â€œMiddle dekho â†’ aadha hatao â†’ repeatâ€


ğŸ§  SHORT INTERVIEW NOTES (WRITE THIS)

Works only on sorted array

Check middle element

Discard half array every step

Stop when low > high

Use low + (high - low)/2 for safety

ğŸ”‘ One-line Memory Trick

â€œMiddle dekho â†’ aadha hatao â†’ repeatâ€

 



## âœ… Method 1: Using **HashSet** (Best / Optimal)

### ğŸ”¹ Steps

1. Create a `HashSet`
2. Insert all elements of the first array into the set
3. Traverse the second array
4. If `set.contains(element)` â†’ element is common

### ğŸ”¹ Java Code

```java
import java.util.*;

class Main {
    public static void main(String[] args) {

        int[] arr1 = {1, 2, 3, 4};
        int[] arr2 = {3, 4, 5, 6};

        HashSet<Integer> set = new HashSet<>();

        // Step 1 & 2: Store first array elements
        for (int x : arr1) {
            set.add(x);
        }

        // Step 3 & 4: Check common elements
        for (int x : arr2) {
            if (set.contains(x)) {
                System.out.println(x);
            }
        }
    }
}
```

### â± Time Complexity

* **O(n + m)**

  * n â†’ size of first array
  * m â†’ size of second array

### ğŸ§  Space Complexity

* **O(n)** (HashSet storage)

### â­ Why this is BEST

* Constant time lookup (`O(1)`)
* Clean & readable
* Most preferred in interviews

### ğŸ—£ï¸ Interview One-Liner

> â€œI use a HashSet to store elements of one array and check the other, giving O(n + m) time complexity.â€

---

## âœ… Method 2: Sorting + Two Pointers (When Extra Space Is Not Allowed)

### ğŸ”¹ Steps

1. Sort both arrays
2. Use two pointers `i` and `j`
3. Compare elements:

   * If equal â†’ print & move both
   * If smaller â†’ move that pointer

### ğŸ”¹ Java Code

```java
Arrays.sort(arr1);
Arrays.sort(arr2);

int i = 0, j = 0;

while (i < arr1.length && j < arr2.length) {
    if (arr1[i] == arr2[j]) {
        System.out.println(arr1[i]);
        i++;
        j++;
    } else if (arr1[i] < arr2[j]) {
        i++;
    } else {
        j++;
    }
}
```

### â± Time Complexity

* **O(n log n + m log m)** (sorting)

### ğŸ§  Space Complexity

* **O(1)** (in-place)

### â­ When to Use

* When interviewer says **â€œno extra space allowedâ€**

### ğŸ—£ï¸ Interview Line

> â€œIf space is restricted, I sort both arrays and use the two-pointer technique.â€

---

## ğŸ”¥ Final Interview Summary

* **Best approach:** HashSet
* **Fastest:** O(n + m)
* **Fallback:** Sorting + two pointers if space is restricted


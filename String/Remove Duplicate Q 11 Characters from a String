
# ðŸŸ¢ Question: Remove Duplicate Characters from a String

---

## ðŸ“Œ Problem Statement

Given a string, **remove duplicate characters** and return the result **while preserving the original order**.

---

## ðŸ“¥ Input

```java
"banana"
```

## ðŸ“¤ Output

```java
"ban"
```

---

## ðŸ§  Approach Used

* **Boolean Array (size 256)** for ASCII characters
* **StringBuilder** to build result efficiently

---

## ðŸ§© Logic (Step-by-Step)

1. Create a boolean array `seen[256]`
   â†’ to track whether a character has appeared before
2. Create `StringBuilder res`
   â†’ to store result string
3. Traverse string character by character
4. For each character:

   * If it is **not seen before**

     * Mark it as seen
     * Add it to result
   * Else â†’ skip (duplicate)
5. Return result as string

---

## âœ… Java Code (With IMPORTANT COMMENTS)

```java
public class RemoveDuplicateCharacters {

    public static String removeDupcharacter(String str) {

        // Boolean array to store visited characters
        // Size 256 because ASCII characters range from 0â€“255
        boolean[] seen = new boolean[256];

        // StringBuilder for efficient string creation
        StringBuilder res = new StringBuilder();

        // Loop through each character of the string
        for (int i = 0; i < str.length(); i++) {

            // Get current character
            char ch = str.charAt(i);

            // Check if character is NOT seen before
            if (!seen[ch]) {

                // IMPORTANT: mark character as seen
                // Without this line, duplicates will NOT be removed
                seen[ch] = true;

                // Add character to result
                res.append(ch);
            }
        }

        // Convert StringBuilder to String and return
        return res.toString();
    }
}
```




ersion 1 (Very simple)

â€œTime complexity is O(n) since we traverse the string once.
Space complexity is O(1) because we use a fixed-size boolean array
---

## â± Time Complexity

```java
O(n)
```

* Each character processed once

---

## ðŸ“¦ Space Complexity

```java
O(1)
```

* Boolean array size is fixed (256)

---

## ðŸš¨ IMPORTANT NOTES (VERY IMPORTANT â€“ REMEMBER THIS)

```java
// seen[ch] = true;
// This line is CRITICAL
// It updates memory that character is already visited
// If you skip this line â†’ duplicates will NOT be removed
```

```java
// boolean[256] works ONLY for ASCII characters
// If Unicode characters are present â†’ use HashSet instead
```

```java
// StringBuilder is used instead of String concatenation
// Because String concatenation is slow in Java
```

---

## âŒ Common Mistakes (Freshers)

```java
// 1. Forgetting: seen[ch] = true
// 2. Using nested loops â†’ O(n^2)
// 3. Using String += ch (slow)
// 4. Not preserving original order
// 5. Using boolean[256] without knowing ASCII concept
```

---

## ðŸ—£ Interview One-Line Explanation

```java
// I use a boolean array to track visited ASCII characters.
// Each character maps to an index, giving O(1) lookup.
// I append only the first occurrence to the result.
```
